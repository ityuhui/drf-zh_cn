# 主导资源公平性（Dominant Resource Fairness）：多种资源类型的公平分配

作者：Ali Ghodsi, Matei Zaharia, Benjamin Hindman, Andy Konwinski, Scott Shenker, Ion Stoica

加州大学伯克利

## 摘要

在一个包含了不同资源类型的系统里，每一个用户对每一种资源都有不同的需求。为了能够在这样一个系统里公平的分配资源，我们提出了主导资源公平性 Dominant Resource Fairness（DRF）算法，一个对多种资源类型的“最大-最小公平”的概括方法。与其他的方法不同，DRF有着非常可取的特性。

首先，DRF通过确保在资源不足的情况下没有用户从中受益，从而激励用户共享资源，将资源在它们之间平均分配。

其次，DRF可以保证, 用户无法通过撒谎来获得更多的资源。

再次，DRF分配资源后，用户不羡慕彼此，即没有用户想要和其他用户交易其分配到的资源。

最后，DRF是Pareto高效的，即在不降低一个用户分配的资源时，不可能提高另一个用户分配的资源。

我们已经在Mesos集群的资源管理器里实现了DRF算法，结果显示，与一些最新的资源调度器里提供的、基于slot的公平分享算法相比，DRF可以带来更好的吞吐量和更公平的分配。

## 1 介绍

分配资源是任何共享计算机系统的重要功能。迄今为止，“最大-最小公平”是最流行的分配策略之一，该策略最大化了一个用户在系统里收到的最小分配。假设每一个用户都有足够的需求，则该策略为每一个用户平均分配这些资源。“最大-最小公平”还包含了“权”的概念，每一个用户收到的资源份额与其权重成正比。

加权的“最大-最小公平”算法的吸引力在于，它很通用，可以支持多种其他的资源分配算法，如基于优先级、资源预留、以及截止日期 [31]。它还确保隔离性，即不管其他用户的需求如何，一个用户一定会收到它的份额。

因为有了上述优点，大量的基于加权“最大-最小公平”算法被提出来，如轮询、按比例共享资源【32】、加权公平排队【12】，这些算法可以被应用于各种资源的分配，包括链路宽带【8，12，15，24，27，29】，CPU【11，28，31】，内存【4，31】以及存储器【5】。

虽然已经有了大量的公平分配算法，但是迄今为止，它们主要关注于单个资源类型的分配。即使在多资源环境下（用户需要不同种类的资源），也总是将其抽象成单个资源来分配。例如，两种广泛使用的集群计算框架：Hadoop和Dryad【1，18，34】，使用的公平调度器，将节点的资源分成固定大小的分区（称之为slot），将其作为调度单元。尽管事实上，集群里的不同任务对CPU、内存和I/O资源的需求非常不同。

在本文中，我们解决了用户对多种类型资源的不同需求的公平分配问题。特别是，我们提出了主导资源公平性（DRF）算法，即对多种资源的“最大-最小公平性”的概况。DRF算法背后的直觉是，在多类别资源环境中，一个用户得到的资源应由该用户的主导资源的份额来确定（主导资源是指用户得到的各种资源里的最大份额）。简而言之，DRF算法寻求最大化所有用户的最小主导份额。举例来说，如果用户A运行着CPU密集型的任务，用户B运行着内存密集型的任务，DRF尝试让用户A的CPU份额和用户B的内存份额相等。在单一资源类型的情况下，DRF退化成该资源的“最大-最小公平”算法。

DRF算法的优点是，它可以满足一些特性，而这些特性在多种资源的情况下是很难得到满足的（在单一资源的情况下比较容易）。对于诸如共享激励、策略防伪、Pareto高效以及无嫉妒，DRF算法保证在一个静态并且平等分配资源的系统里，没有用户会过得更好，从而激励用户共享资源。进一步说，DRF算法具有预防策略，没有用户可以通过撒谎来获得更多的资源。DRF是Pareto高效的，即在不抢占已经分配出去的资源的情况下，它尽可能的分配资源以满足其他的属性。最后，DRF是不产生嫉妒的，没有用户想要别人的资源。而其他的解决方案至少会违反上面的一个属性。例如，在微观经济学里的优先公平分配机制【3，22，33】，以及平等参与的竞争均衡【3】都不具有预防策略。

我们已经在Mesos【16】（一个运行于多种集群计算框架如Hadoop、MPI上的资源管理器）里实现并评估了DRF算法。与Hadoop和Dryad里采用的基于slot的公平分享算法相比，基于slot的公平分享算法会带来更糟糕的性能，对特定的工作负载的不公平的惩罚，以及更加虚弱的隔离性。

尽管本文着重于数据中心的资源分配，但我们认为DRF算法通常也适用于用户有不同需求的其他的多资源环境，例如在多核计算机中。

本文的其余部分安排如下：第2节提出了多资源的公平性问题。第3节列出了我们想要考虑的公平性的属性。第4节介绍DRF算法。第5节介绍公平性的替代概念。第6节则分析了DRF算法和其他算法的属性。第7节提供了在Facebook Hadoop集群中的实验​​结果。第8节中对相关工作进行了调查。第9节中进行了总结。

## 2 动机

之前，关于加权的“最大-最小公平性”算法专注于单一资源，但是随着云计算和多核处理器的出现，对具有多个资源以及不同的用户需求的环境里的资源分配算法的需求逐渐增多。多个资源是指不同类型的资源，而不是同一类可互换的多个资源。

为了弄清楚多资源分配的需求，我们绘制了一副图（图1），该图追踪了在一个月（2010年10月）的时间里，Facebook的一个2000个节点的Hadoop集群的资源分配情况，图1中的一个圆圈代表某个任务消耗的内存和CPU资源。圆的大小是该圆所在区域里的任务的数量的对数。虽然大多数任务是CPU密集性的，但也有一些内存密集型的任务（尤其是reduce操作）。

现有的集群中使用的公平调度器，如Quincy【18】和Hadoop公平调度器【2，34】，都忽略了用户的异构请求（对多种资源的不同请求），以粗粒度的slot(一个slot是一个节点的全部资源中的固定的一部分)来分配资源。因为slot通常与任务要求的资源不匹配，从而导致分配效率的低下。

图2量化了Hadoop MapReduce里公平调度器【2，34】提供的公平和隔离的级别。该图展示了任务对CPU的需求和slot的CPU份额之间的比率，以及任务对内存的需求和slot的内存份额之间的比率。我们通过将总的内存和CPU数量除以slot的个数，计算出每个slot对应的CPU和内存份额。比率等于1代表任务需求和slot资源之间完美匹配，比率低于1代表任务未充分利用其slot资源，比率高于1对应任务过度利用其slot资源，这可能会导致颠簸。图2显示大多数任务要么使用不足，要么过度使用了其slot资源。修改每台机器的slot数无法解决这个问题，因为这可能会导致总体利用率较低或者因过度使用而导致性能不佳（请参见第7节）。

## 3 资源分配的属性

现在，我们将注意力转向为多种异构的资源请求设计最大-最小公平算法。为了阐述这个问题，假设有一个由9个CPU和18 GB内存组成的系统，有两个用户，用户A每个任务需要<1 CPU，4 GB内存>，用户B每个任务需要<3 CPU，1 GB内存>。这种情况下的公平分配算法是怎么样的呢？一种可能的方法是将每种资源平均分配给每个用户。另一种可能的方法是将资源汇总（例如，CPU加上内存）均衡地分配给每个用户。虽然想出一个可能“公平”的算法不难，但是如何来评估和比较这些算法就不得而知了。

为了应对这一挑战，我们从一组理想的属性开始（我们认为多种异构的资源分配算法都满足这些属性）。我们发现以下四个属性很重要：

1. 分享激励：相比较于独占部分资源，在共享的集群里每个用户可以执行更多的任务。例如在一个相同的节点和n个用户组成的集群里，一个用户在总资源的1/n的集群分区里，无法比原来在整个共享的集群里执行更多的任务。

2. 策略防伪：用户不应该通过说谎来得到更多的资源。这一条是兼容于“分享激励”的，因为用户不能通过撒谎来改善其分配。

3. 无嫉妒：用户不应当喜欢其他人的分配，此属性体现了公平性的概念【13，30】。

4. Pareto高效：不应该通过减少其他用户分配，来增加一个用户的资源。该属性很重要，因为它可以最大化系统的利用率以满足其他的属性。

我们简要的评论一下“策略防伪”和“分享激励”这两个属性，因为我们认为它们在数据中心环境中特别重要。在与云运营商的交谈中我们得知，“策略防伪”很重要，因为用户经常尝试操纵调度程序。举例来说，在雅虎的一个Hadoop MapReduce数据中心里，map或reduce任务定义的slot数不同。当用户发现map任务正在与其他用户竞争资源，他会手动的将所有工作改由reduce任务来完成。另一家大型的搜索公司给高利用率的任务提供专用的机器资源，但是不久它就发现，用户在他们的代码里加入无限循环从而人为的提高任务的利用率水平。

此外，任何满足“分享激励”的策略都能做到性能隔离，因为它保证每个用户的最小分配（例如，用户不会比在1/n个资源的集群里更糟糕），而不必考虑其他用户的需求。

很容易表明，在单一资源的情况下，最大-最小公平性算法满足上述所有的属性。但是，在多种异构的资源需求的情况下，要实现这些特性就不容易了。例如，在微观经济学理论中的首选公平分配机制，来自均等收入的竞争性平等算法【22，30，33】，都不是“策略防伪”的（请参见第6.1.2节）。

除了上述属性，我们还考虑四个“最好能有”的属性：

- 单一资源公平：对于单一资源，该算法降级为“最大-最小”公平算法。
- 瓶颈公平：如果一种资源对于大部分用户都按照百分比分配，那么该算法对该资源降级为“最大-最小”公平算法。
- 整体单调性：当一个用户离开系统并释放她所有的资源，剩余用户的分配都不会降低。
- 资源单调性：如果系统增加了资源，没有用户的分配会降低。

## 4 主导资源公平性 Dominant Resource Fairness(DRF)

我们提出了一个新的针对多种资源的分配算法——主导资源公平性（DRF）算法，该算法满足上个章节描述的所有四个属性。对于每一个用户，DRF算法计算出该用户的每一种资源的份额，所有资源中最大的份额值，被称为该用户的“主导份额”，该资源被称为“主导资源”。不同的用户可能有不同的主导资源，例如，一个计算密集型任务的用户的主导资源是CPU，一个I/O密集型任务的用户的主导资源是带宽。DRF算法在用户的主导份额之间简单的使用最大-最小公平性算法，也就是说，DRF算法试图最大化系统里最小的主导份额，接下来是第二小，以此类推。

我们从4.1节开始，首先展示一个DRF的例子，在4.2节介绍DRF算法，4.3节介绍加权DRF算法。在第5章，我们会给出另外两个算法：资产公平性算法，一种旨在均衡总资源的简单算法；以及从平等收入获得的竞争均衡（CEEI）算法，这是一个在微观经济领域广受欢迎的公平分配算法【22，30，33】。

在这一章里，我们假设有一个由n个用户和m种资源组成的计算模型。每一个用户都运行着各自的任务，每一个任务都有一个需求向量，该向量指明了该任务需要的资源的数量。例如<1 CPU, 4 GB内存>。通常，即使属于同一个用户的任务也有着不同的资源需求。

### 4.1 例子

假设有一个系统，由9个CPU和18 GB内存组成，它有两个用户，用户A运行的每个任务的需求向量是 <1 CPU, 4 GB>，用户B运行的每个任务的需求向量是 <3 CPU, 1 GB>。

在上述场景里，用户A的每个任务消耗总CPU的1/9、总内存的2/9，因此用户A的主导资源是内存。用户B的每个任务消耗总CPU的1/3、总内存的1/18，所以B的主导资源是CPU。DRF算法使用户的主导份额相等，因此如图3所示分配资源：用户A运行3个任务，一共消耗<3 CPU, 12 GB>，用户B运行2个任务，消耗的总资源是<6 CPU, 2 GB>。每个用户都得到了相同的主导份额，例如，用户A得到了总内存的2/3，用户B得到了总CPU的2/3。

这一分配算法可以被数学的表述为：让x等于用户A运行的任务数，y等于用户B运行的用户数，则用户A收到的资源是 < x CPU, 4x GB>，用户B收到的资源是 < 3y CPU, y GB>，那么两个用户获得的总的资源是 (x+3y) CPU 和 (4x+y) GB。同时，A的主导份额 (2x/9) = B的主导份额 (y/3), DRF算法其实就是下列优化问题的解法：

max(x,y) (最大化分配)
满足
x + 3y <= 9 (CPU 限制)
4x + y <= 18 (内存限制)
2x/9 = y/3 (主导份额相等)

解出这个问题得到x=3, y=2 (注意：最后一个限制, 2x/9 = y/3 使得x和y同时最大化)，也就是说，用户A得到<3 CPU，12 GB>，用户B得到<6 CPU, 2 GB>。

注意，DRF算法不必一定要让每个用户的主导份额相等。当满足一个用户的总需求后（该用户不需要更多的任务），多余的资源将在其他用户之间进行分配，就像在最大-最小算法中一样。另外，如果某个资源用尽，不需要该资源的用户可以继续接收更高份额的其他资源。我们将在下一部分提出详细的DRF分配算法。

### 4.2 DRF 调度算法

算法1 展示了DRF调度的伪代码。该算法追踪了分配给每个用户的总资源以及该用户的主导份额，si。在算法的每一步，DRF在有任务将要运行的用户中挑出主导份额最小的用户。如果该用户的任务资源需求被满足（例如，系统里有足够的资源），则启动她的一个任务。我们认为，通常来说，用户有不同的任务，需求向量各不相同，可以使用变量 Di 来表示用户 i 的下一个要启动的任务的需求向量。出于简单考虑，伪代码并不捕获一个任务结束的事件。在这种情况下，用户释放任务的资源，DRF再次挑出主导份额最小的用户以运行她的任务。

来考虑4.1节中的两个用户的例子，表1展示了DRF算法对这个例子的分配过程。DRF首先挑出B来运行一个任务，之后，B的份额变成<3/9, 1/18>，主导份额是max(3/9, 1/18) = 1/3。接下来，DRF挑出A，因为她的主导份额是0。持续这一过程，直到再也不可能运行新的任务了。在这个例子里，是因为CPU已经饱和了。

在上述分配的最后，用户A获得了<3 CPU, 12 GB>，用户B获得了<6 CPU, 2 GB>，每一个用户都得到了它的主导资源的2/3。

注意，在这个例子里，一旦任意一个资源饱和，分配就会停止。但是，在一般情况下，即使某个资源饱和了，系统还可能继续分配任务，因为有一些任务并不需要那种饱和的资源。

上述算法在实现时，可以使用二叉堆（binary heap）来存储每个用户的主导份额，因此每次调度对于n个用户的时间复杂度是O(logn)。

### 4.3 加权的 DRF

在实践中，用户之间平等地分配资源在很多时候并不是理想的分配策略。我们可能需要给重要的任务分配更多的资源，或者给那些贡献资源多的用户更多的资源。为了达到这个目标，我们提出家加权的 DRF 算法，一种对 DRF 算法和加权的“最大最小”公平算法两者的概括。

在加权的 DRF 算法中，每一个用户i有一个权值向量Wi=<wi1, ..., wim>，其中wij表示用户i对资源w的权重值。用户i的主导份额的定义就变成si = max j (uij / wij)，其中 uij是用户i拥有的的资源j的份额。一个特别有趣的情况是：当用户i的所有权值都相等，例如，wij = wi (1 <= j <= m), 在这种情况下， 用户i和用户j的主导份额的比率将简化成 wi / wj。如果所有用户的权值都是1的话，加权的 DRF 算法就退化为普通的 DRF 算法。

## 5 其它的公平分配算法

在一个多资源系统里定义一个公平分配算法并不容易，因为“公平”这一概念本身就需要讨论。我们考虑了众多分配算法，最后认为只有 DRF 算法满足以下所有四个必需属性：分享激励，策略防伪，Pareto高效，以及无嫉妒。在本章中，我们讨论其中的两个算法：资产公平性算法，一种简单而直观的策略，旨在将总资源均衡地分配给每个用户。从平等收入获得的竞争均衡（CEEI）算法，这是一个在微观经济领域公平分配资源的算法【22，30，33】。在第5.3节里，我们将这些算法与 DRF 进行了比较。

### 5.1 资产公平性

资产公平性背后的想法是不同资源的价值是相等的，即 1% 的 CPU 的价值等于 1％ 的内存的价值，或者等于 1％ 的带宽的价值。资产公平性算法试图将资源的总值平均地分配给每个用户。具体来说，资产公平性算法计算每个用户的总份额 xi = 对所有的j求和(sij)，sij是用户i分配到的资源j的份额。然后，它对用户的总份额应用最大最小公平算法（重复的启动具有最小总份额的用户的任务）。

考虑4.1节中的例子，因为内存的数量是CPU的两倍（9 CPU，18 GB 内存），因此1 CPU 的价值是 1 GB 内存的两倍。假设 1 GB 内存的价值是1美元，那么1 CPU 的价值就是2美元，接下来可以得到，用户A每运行一次任务需要6美元，用户B则需要7美元。用x, y分别表示资产公平性算法分配给用户A和用户B的任务数，那么该算法可以用下面的优化问题的解法所解决：

max (x,y) (最大化分配)
等于
x + 3y <= 9 (CPU 限制)
4x + y <= 18 (内存限制)
6x = 7y (每一个用户的花费都相等)

解上面的问题可以得到 x = 2.52 且 y = 2.16, 因此，用户A得到<2.5 CPU, 10.1 GB>，用户B得到 <6.5 CPU, 2.2 GB>。

虽然这种分配策略非常简单，但是它有一个明显的缺点，就是违反了“分享激励”属性。如第6.1.1节所示，资产公平性算法可能导致一位用户的收益少于系统中总资源的 1 / n，其中 n 是用户总数。

### 5.2 从平等收入获得的竞争均衡算法

在微观经济学理论里，平等分配资源最常采用的是“从平等收入获得的竞争均衡（CEEI）”算法【22，30，33】，该算法将每个用户收到的资源初始化为每种资源的 1/n ，接下来，所有用户在一个充分竞争的市场里相互交易。CEEI的最终结果是“无嫉妒”并且“Pareto高效的”【30】。

更准确的说，CEEI分配由纳什议价方案【22，23】给出。纳什议价方案找到可以最大化ui(ai)之和的分配分案，ui(ai)是用户i从她的分配ai中得到的效用。为了简化比较，我们假设一个用户从她的分配中得到的效用就是她的主导份额si。

再次考虑4.1节中的那个两个用户的例子，回忆一下，用户A的主导份额是 4x/18 = 2x/9，用户B的主导份额是 3y/9 = y/3，x是用户A的执行任务数，y是用户B的执行任务数。最大化主导份额的乘积等于最大化x*y的结果。因此，CEEI算法的目的是解决下面的优化问题：

max（x*y）   （最大化纳什乘积）
等于
x + 3y <= 9 (CPU 限制)
4x + y <= 18 (内存限制)

解决上述问题，得到 x = 45 / 11， y = 18 / 11，因此，用户A得到了<4.1 CPU, 16.4 GB>，用户B得到了<4.9 CPU, 1.6 GB>。

虽然 CEEI 算法是“无嫉妒”并且“ Pareto 高效”的，但是我们将在6.1.2节中展示它并不是“策略防伪”的。因此用户可以通过谎报资源需求来增加其分配。

### 5.3 与 DRF 的对比

为了让用户对资产公平性算法和CEEI算法有一个直观的理解，我们在图4中将其与4.1节中的DRF算法进行了比较。

可以看出，DRF算法使得用户的主导份额相等，例如，用户A的内存份额等于用户B的 CPU 份额。作为比较，资产公平性算法使得每个用户的总的资源总量相等，例如，在图4中，每个用户的所有矩形的面积之和相等。最后是CEEI，因为它假设出了一个充分竞争的市场环境，所以它可以清空市场，即将每一个资源都分配掉。不幸的是，CEEI有可能被欺骗，一个用户可以声称它需要更多的资源（事实上它并不需要），从而使得CEEI赋予其更多的任务，因为CEEI必须清空整个市场。

## 6. 分析

在这一章里，我们将讨论资产公平性算法，CEEI 算法以及 DRF 算法分别满足第三章列出的哪些属性。以及评估当任务的规模与可用的资源并不严格匹配时，DRF 算法的准确性。

### 6.1 公平性属性

表2总结了资产公平性算法，CEEI 和 DRF 算法满足的公平性属性。附录包含 DRF 算法的主要性质的证明，而我们的技术报告【14】包含更完整的针对 DRF 和 CEEI 结果的列表。在本章的剩余部分，我们将讨论一些表2中有趣的缺失条目，例如，被每一条原则打破的属性。我们还将通过例子，来展示为什么资产公平性算法和 CEEI 算法缺乏一些属性。我们也将证明，没有算法可以在不违反“共享激励”或“Pareto高效”的情况下提供资源的单调性，从而揭示了为什么 DRF 算法不具备资源单调性。

#### 6.1.1 资产公平性算法违反的属性

作为最简单的算法，资产公平性算法违反了一些重要的属性：“分享激励”，“瓶颈公平性”，以及资源单调性。接下来，我们使用例子来介绍这些属性是如何被违反的。

##### 定理1 资产公平性算法违反了“分享激励”属性 

##### 证明
如图5所示的一个例子：一个系统的总资源是<30,30>，两个用户的需求向量分别是 D1=<1,3>, D2=<1,1>。资产公平性算法给第一个用户分配 6 个任务，给第二个用户分配 12 个任务，第一个用户获得<6, 18>，第二个用户获得<12, 12>, 每个用户获得总份额 24/60 是相等的，第二个用户获得的每种资源都少于1/2。这违反了“分享激励”属性，因为第二个用户如果将集群分区并将其中一半节点的据为己有的话，将会获得更好的分配。

##### 定理2 资产公平性算法违反了“瓶颈公平”属性 

##### 证明
考虑这样一个场景：总的资源向量是<21, 21>，有两个用户，其需求向量分别是 D1=<3, 2>, D2=<4, 1>，资源1是瓶颈资源。资产公平性算法给每一个用户都分配 3 个任务， 使得二者的总份额都等于15。但是，第一个用户仅获得了瓶颈资源（资源1）的 3/7, 这违反了“瓶颈公平”。

##### 定理3 资产公平性算法不满足资源单调性

##### 证明
考虑两个用户A和B，其需求分别为<4, 2>和<1, 1>，两种资源各有 77 个。资产公平性算法给A一共分配<44, 22>，给B一共分配<33, 33>，使其总的份额都等于 66 / 77。如果第二种资源的数量翻倍，那么两个用户的第二种资源的份额将减半，第一种资源将饱和。资产公平性算法为了使其总份额相等，降低了A的分配，为<42, 21>，但是提高了B的分配，为<35, 35>, 现在两者的份额是 42/77 + 21/154 = 35/77 + 35/154 = 105/154。这违反了资源单调性。

#### 6.1.2 CEEI算法违反的属性
CEEI算法是“无嫉妒”和“Pareto高效”的，但是它并不满足“策略防伪”。从直觉来看，这是因为CEEI算法假设了一个充分竞争的市场，可以清空市场，例如，它通过匹配供需从而分配完所有的可得的资源。这可能导致CEEI算法为那些使用了更多的“竞争较少”的资源的用户分配更高的份额，以便充分的利用该资源。因此，用户可以声称她需要更多一些未充分利用的资源来增加的她的总体资源份额。

##### 定理4 CEEI算法不是“策略防伪”的

##### 证明
考虑如图6所示的例子，系统里总的资源是<100, 200>，两个用户的需求分别是<16, 1>和<1, 2>。在这一情况下，CEEI算法分别给每个用户分配 100/31 和 1500/31 个任务（大概是 3.2 和 48.8 个任务）。如果用户1更变她的需求为<16, 8>， 请求更多的资源2（比她事实上需要的要多）， CEEI算法将给每个用户分配 25/6 和 100/3 个任务（大概是 4.3 和 33.2 个任务）。因此，用户1通过撒谎将她的任务数从3.2提升到4.2，用户1的受到了损失，其任务数下降了。

除此之外，出于同样的直观的原因（市场清空），我们还得到了以下的结果：

##### 定理5 CEEI算法违反了总体单调性

##### 证明
考虑总资源<100, 100>，三个用户，其需求向量分别是 D1=<4, 1>，D2=<1,16>，D3=<16, 1> （参见图7）。CEEI将给出分配A1 = <11.3, 5.4, 3.1>，括号中的数字代表了分配给每个用户的任务数。如果用户3离开系统并放弃她的资源，CEEI 给出新的分配 A2 = <23.8, 4.8>，这使用户2得到的分配与之前的相比变得糟糕了。

#### 6.1.3 资源单调性对比分享激励和 Pareto 高效

正如表2所示，DRF算法具备除资源单调性之外的所有属性。这并不是 DRF 算法的缺陷，而是同时满足“分享激励”和“Pareto高效”带来的后果。因为我们认为这两个属性更加重要，并且向系统中添加资源这一事件并不常见，所以，我们选择满足“分享激励”和“Pareto高效”，放弃资源单调性。因此，我们得到下面的结果：

##### 定理6 没有任何分配算法，可以既满足“分享激励”和“Pareto”高效，同时又满足资源单调性

##### 证明
我们用一个简单的例子来证明这一属性。考虑两个用户A和B，有着对称的需求<2, 1>和<1, 2>，假设两种资源的数量相等。“分享激励”要求用户至少得到资源1的一半，用户B得到资源2的一半。“Pareto 高效”要求这两个用户中至少一个必须得到更多的资源。不失一般性，假设用户A得到的超过一半的资源1（作为对称，用户B得到超过一半的资源2）。如果资源2的总量现在增加了，因子为4， 用户B再也无法得到资源2的一半。现在，满足“分享激励”的唯一可行的分配是给予两个用户资源 1 的一半，这将减少用户A的资源1的份额，从而违反资源单调性。

这一定理解释了为什么 DRF 算法和 CEEI 算法都违反了资源单调性。

### 6.2 离散资源分配

迄今为止，我们都假设在一个大的资源池里，资源可以任意小的数量进行分配。但是在实际中这种情况可能并不多见，例如，某种资源由很多小的机器组成，其资源必须被离散的分配给任务。在这一节中，我们用“连续”和“离散”来指代这两种情况。现在我们将注意力转向公平性在离散场景中受到怎样的影响。

假设有一个集群，由 K 个机器组成。max-task 表示所有需求向量中的最大需求向量，例如， max-task = < maxi{di,1}, maxi{di,2}, ..., maxi{dj, m}>。进一步假设，任意任务都可以被调度到每一台机器上，例如，每一台机器的资源总和至少是max-task。我们只考虑每一个用户都有严格的正需求这一情况。 在给定这些假设之后，我们得到下面的结果：

##### 定理7 与连续分配方案相比，在离散场景中，分配资源使得任意两个用户的所有位置之间的差异以一个max-task为界

##### 证明
假设我们每次在一台机器上分配资源，并且总是将任务分配给主导份额最低的用户。只要第一台机器上至少还存在一个max-task，我们就继续把任务分配给下一个主导份额最小的用户。直到第一台机器上的资源小于一个max-task，我们转到下一台机器上，并重复之前的流程。当分配完成时，与连续分配相比，两个用户对其主导资源的分配之间的差异最多是 max-task。如果不是，那么用户A将比用户B有超过max-task的差异w.r.t。但是这不可能，因为在最后一次，A获得了一个任务，那么B也应该被分配一个任务。

## 7 实验结果

这一章通过微观和宏观的测试方法来评估 DRF 算法。前者通过在 Mesos 集群资源管理器中实现一个 DRF 来完成。后者通过跟踪驱动的模拟来实现。

在7.1节，我们将展示 DRF 算法如何动态的调整带有不同资源需求的任务的份额。在7.2节，我们将 DRF 算法与 slot级的公平分享算法（Hadoop公平调度器[34]和Quincy[18]中实现的算法），CPU公平分享算法进行对比。最后，我们将在7.3节中，使用 Facebooke 追踪来比较 DRF算法 和 Hadoop公平调度器二者的资源利用率和任务完成时间。

### 7.1 动态资源共享

在第一个实验里，我们将展示 DRF 如何在不同需求的任务之间动态的共享资源。我们在亚马逊EC2上，在一个48个节点（“最大”实例，4 CPU 15GB 内存）组成的 Mesos 集群里运行了两个任务。我们配置 Mesos 可以对每一个节点，最多分配 4 CPU，14 GB 内存的资源（留下 1 GB 内存给操作系统）。在六分钟间隔里，我们提交了两个拥有不同的资源需求的任务。

图8(a)和8(b)展示了某个任务的CPU 和内存的分配对时间的函数， 图8(c)展示了任务的主导份额对事件的函数。在前两分钟，工作1每个任务使用了<1 CPU, 10 GB 内存>，工作2每个任务使用<1 CPU, 1 GB 内存>。工作1的主导份额是内存，工作2的主导份额是CPU。注意 DRF 使两个工作的主导份额相等。除此之外，因为不同的工作负载有不同的主导资源，它们的主导份额都超过了 50%， 例如，工作1使用了大概 70% 的内存， 工作2使用了大概 75% 的 CPU资源。因此，相比较各自独占一个集群里一半的机器，工作负载运行在一个共享资源的集群里更加收益。这就是“共享激励”属性的本质。

两分钟之后，工作1的任务大小变成 <2 CPU, 4 GB 内存>， 工作2的任务大小变成 <1 CPU, 3 GB 内存>，现在，两个工作的主导资源都是 CPU，所以，DRF算法使二者的CPU份额相等。注意，当任务结束以后，DRF 通过 Mesos 向拥有最小的主导份额的工作分配资源，从而动态的切换分配。

最终，又过了两分钟之后，工作1的任务大小变成 <1 CPU, 7 GB 内存>，工作2的任务大小变成<1 CPU, 4 GB 内存>。两个工作现在的主导资源都变成了内存，因此 DRF 尝试让它们的内存份额相等。份额没有完全一致的原因是资源的碎片化（看6.2节）。

### 7.2 DRF 与 替代分配策略 的对比

接下来我们评估 DRF 与两个替代方案：基于slot的公平调度（目前广泛使用的策略，例如 Hadoop 公平调度器【34】和 Quincy【18】）和单资源（CPU）的最大-最小公平分享算法。这次实验在一个运行了48个节点（EC2实例，每实例 8 CPU 和 7 GB 内存）的Mesos集群上，我们配置Mesos可以从每个机器分配 8 CPU 和 6 GB 内存，留下 1 GB 内存给操作系统。我们将这三个调度策略实现为 Mesos 的分配模块。

我们运行了一个有两类用户的工作负载，分别代表了有不同工作负载的两种组织实体。第一个组织有四个用户，提交小型工作<1 CPU, 0.5 GB 内存>。另一个组织有四个用户，提交大型的任务<2 CPU, 2 GB 内存>。每一个工作都由80个任务组成。当一个工作结束以后，用户会启动另外一个相同资源需求的工作。每一个实验都运行十分钟，最后，我们计算出每种类型的工作的完成数量，以及它们的响应时间。

对于基于slot的分配方案，我们设定每台机器的slot数从3到6不等，来观察slot数对于性能的影响。图9到图12展示了实验结果。在图9和图10里，我们比较了在10分钟里，在每种调度架构下，各类型的工作的完成数量。图11和图12展示了平均响应时间。

从这些数据里可以看出一些趋势，首先，无论slot数量设定多少，基于slot的调度算法的吞吐量和工作响应时间都比 DRF 算法要差。这是因为，当slot数很小的的时候，调度器可以使用调度不足的节点（例如，在一个节点上只启动3个小任务），而当slot数较大，它将过度的使用节点（例如，在一个节点上启动4个大任务，因为每个任务都需要2 GB内存，但是该节点总共只有6 GB内存，从而引起内存交换）。其次，CPU公平调度算法执行小型任务的数量与 DRF 算法近似。但是其执行大型任务的数量要远远少于 DRF。这是因为内存在某些节点上被过度使用，从而导致所有的消耗内存高的任务性能表现不佳。总而言之，能够感知两种资源的、基于DRF的调度器，有着最低的响应时间和最高的整体吞吐量。

### 7.3 使用 Facebook Traces 进行模拟

接下来，我们追踪一个来自Facebook的2000个节点的集群的日志，该日志数据持续一周（2010年10月），由Hadoop MapReduce作业组成。我们假设任务持续时间、CPU使用率和内存消耗与原始跟踪相同。跟踪在一个400节点的较小的集群上模拟，以达到更高的利用率，在此情形下，公平性非常重要。集群中的每一个节点由12个slot、16核和 32 GB内存组成。图13展示了一个短的300秒的子采样，可视化对于相同的工作负载，DRF算法对比Hadoop公平调度器（基于slot）的CPU和内存利用率。如图所示，DRF 提供了更高的利用率，因为它可以根据任务的需求更好的匹配资源的分配。

图14展示了在减少任务平均完成时间方面，DRF与Hadoop公平调度器的比较。当小型的作业比较多时，DRF没有任何提升（例如，- 3%）。这是因为小型作业一般只有一个执行阶段，其完成时间主要取决于耗时最长的那个任务。因此对于小型作业来做，很难改善其完成时间。但是，大型作业的完成时间可以减少多达66%，这是因为这些作业由许多的阶段组成，可以受益于 DRF 算法带来的高利用率。 

## 8 相关工作

我们简要的回顾一下计算机科学和经济学里的一些相关的工作。

虽然计算机科学领域的许多论文都关注多资源公平性，但是它们都只考虑同一可互换的资源的多个实例，例如，CPU【6，7，35】和带宽【10，20，21】。与这些方法不同，我们专注于不同类型的资源的分配。

Quincy【18】是一个在 Dryad 集群计算框架里开发的调度器。它将公平调度问题建模为一个最小-代价流问题，从而达到公平性。目前Quincy不支持多类型资源的公平性。实际上，正如论文【18，第17页】所提到，将最小-代价流公式应用于多类型资源的需求中是非常难的。

Hadoop目前提供了两个公平调度器【1，2，34】.二者都在slot粒度分配资源，slot是一台机器上的一组固定的资源。因此，这些调度器并不总能匹配任务的资源需求，特别是当需求非常不同。正如我们在第七章所展示的，这一不匹配使得资源过度订阅，导致集群利用率过低或者性能很差。

在微观经济学文献中，公平问题已经在博弈论框架内外进行了研究。Young【33】和Moulin【22】的书致力于这些主题并提供了很好的介绍。在微观经济学领域最受欢迎的公平分配方法是 Varian【30】引入的 CEEI【3，33，22】。我们已经在第5.2节中对其进行了相当大的关注。与DRF相比，CEEI主要的缺点是它不是“策略防伪”的。因此，用户可以通过谎报自己的需求来操作调度器。

微观经济学文献中提出的许多公平分配策略都基于“效用”这一概念，而且专注于单一指标。在经济学文献中，最大最小公平算法被称为实用的字典顺序【26, 25】(leximin) 算法。

问题是效能在多类型资源环境下如何设置，以及如何比较这些效能。一种很自然的方法是将效能定义为每个用户分配得到的任务数。但是这种方式建模的效能，与leximin算法一起，违反了我们之前提出的一些公平性属性。从这个角度来看， DRF 有两个贡献，首先，它使用主导份额来代替效能（使用标准的leximin排序使之相等化）。其次，我们可以证明该算法对于此类效能是“策略防伪”的。注意，leximin 排序是Kalai Smorodinsky 方案的字典版本【19】。因此，我们的结果证明KS方案针对这种效能是“策略防伪”的。

## 9 结论和未来的工作

我们介绍了主导资源公平性（DRF）算法，一种泛化的使得多种类型资源最大-最小公平的公平共享模型。 DRF算法让集群调度器能够处理数据中心程序的异构需求，在资源的公平分配，以及高利用率都比目前的基于资源切片（slot）方案要好。DRF可以满足需要的属性。尤其特别的是，它是“策略防伪”的，因此用户必须准确的报告它们的需求。由于DRF算法确保用户在共享资源的环境下不会比独占资源要差，所以它还可以激励用户分享资源。我们研究的其他的调度器，以及微观经济学文献里提到的替代公平的概念，都无法满足所有这些属性。

通过在 Mesos 资源管理器里的实现 DRF 算法，我们可以得知，与目前广泛采用的基于slot的公平调度器相比，DRF 可以获得更好的性能。

### 9.1 未来的工作

未来的研究有一些有趣的方向。首先，在拥有离散任务的集群环境下，一个有趣的问题是如何在不影响公平性的前提下，最大限度的减少资源碎片。这个问题类似于“装箱”问题，但是必须在满足 DRF 的需求下装入尽可能多的任务。第二个方向是在任务有调度限制的情况下如何定义公平性，例如，偏好某类型的机器。当前，在多核机器被广泛采用的趋势下，第三个方向是探索 DRF 在操作系统调度器中的使用。最后，从微观经济领域的展望来看，一个自然的方向就是，在满足其他属性（例如“Pareto”高效）的情况下，调研 DRF 是否是对于多类型资源的唯一可能的“策略防伪”的算法。

## 10 致谢

感谢 Eric J. Friedman, Herve Moulin, John Wilkes，以及匿名评搞人的珍贵的反馈。感谢 Facebook 完成了算法在环境里的追踪。本研究受到以下结构的支持：California MICRO, California Discovery, the Swedish Research Council, the Natural Sciences and Engineering Research Council of Canada, a National Science Foundation Graduate Research Fellowship，the RAD Lab sponsors: Google, Microsoft, Oracle, Amazon, Cisco, Cloudera, eBay, Facebook, Fujitsu, HP, Intel, NetApp, SAP, VMware, and Yahoo!

## 参考

请见英文原文

## 附录 A ：DRF 的属性

在本附录中，我们给出 DRF 算法的主要属性，技术报告【14】包含了一个 DRF 和 CEEI 的更加完整的列表。对于上下文，以下表格总结了资产公平性算法，CEEI 以及 DRF 各自满足的的属性。

在本节中，我们假设所有用户都有无限数量的任务。此外，我们假设一个用户的所有任务都有相同的需求向量，我们将把这个向量称为用户的需求向量。

接下来，我们提出了渐进式填充【9】，这是一种在所有资源都可以任意分配时，实现 DRF 算法的简单技术。这种技术可以证明我们的结果。

### 附录 A.1 DRF 渐进式填充

DRF 渐进填充实际上是在资源可以任意切分的系统里的一种最大-最小公平性算法【9， 第450页】。它最初用于网络环境，但是现在被应用于在我们的问题里。在DRF中，渐进式填充以相同的速率，增加所有用户的主导份额，同时，也根据它们的任务需求向量来按比例增加其他资源的分配，直到至少一个资源被用尽。这个时候，所有使用该种资源的用户的分配将会被冻结，在除去这些用户之后，渐进式填充算法继续递归的执行，直到最终没有一个用户的主导份额可以增长为止。

在正确缩放用户的需求向量后，DRF 渐进式填充算法等价于图1所展示的调度算法。特别是，每个用户的需求向量被缩放，根据缩放后的需求向量给该用户分配资源，将以一个所有用户都相等的固定值，提高其主导份额。假设$D_i=<d_{i,1}, d_{i,2}, ..., d_{i,m}>$是用户 $i$ 的需求向量，$r_k$是其主导资源，$s_i = \frac {d_{i,k}} {r_k} $是其主导份额。我们以 $\frac {\epsilon} {s_i} $ 缩放用户 $i$ 的需求向量，如 $D'_i= \frac {\epsilon} {s_i}D_i = \frac {\epsilon} {s_i}<d_{i,1}, d_{i,2}, ..., d_{i,m}>$。因此，每当用户 $i$ 的一个任务被选中时，她被分配主导资源的 $\frac {\epsilon} {s_i}d_{i,k} = \epsilon r_k$，这意味着用户 $i$ 的主导份额增长了 $(\epsilon r_k)/r_k = \epsilon$

### 附录 A.2 分配属性

我们从初步结果开始。

#### 引理 8 DRF 分配中的每个用户至少有一种饱和资源

状态-->正在翻译
